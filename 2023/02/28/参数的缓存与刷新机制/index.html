<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="参数简介众所周知，参数是我们在设计灵活可配置的应用程序时必不可少的一种手段。在不改变运行中的代码的前提下，通过修改参数的值来控制程序的执行结果。参数可以被持久化到数据库，可以被写入本地文件，也可以被缓存到JVM。 什么样的参数适合放入缓存？数据量可控，读多写少，允许集群内较小时间范围里不一致的参数可以放入缓存。">
<meta property="og:type" content="article">
<meta property="og:title" content="参数的缓存与刷新机制">
<meta property="og:url" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="团队技术分享博客">
<meta property="og:description" content="参数简介众所周知，参数是我们在设计灵活可配置的应用程序时必不可少的一种手段。在不改变运行中的代码的前提下，通过修改参数的值来控制程序的执行结果。参数可以被持久化到数据库，可以被写入本地文件，也可以被缓存到JVM。 什么样的参数适合放入缓存？数据量可控，读多写少，允许集群内较小时间范围里不一致的参数可以放入缓存。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/%E7%BC%93%E5%AD%98.JPG">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/apollo.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/pollandquery.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/s-s-p.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/queryConfig.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/poll.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/configfactory.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/RemoteConfigRepository.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/configservice.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/release.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/notify.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/file.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/step.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/nacos1.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/nacos2.jpg">
<meta property="og:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/redis.jpg">
<meta property="article:published_time" content="2023-02-28T12:13:14.000Z">
<meta property="article:modified_time" content="2023-04-14T00:55:36.000Z">
<meta property="article:author" content="team-manager">
<meta property="article:tag" content="参数">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/%E7%BC%93%E5%AD%98.JPG">

<link rel="canonical" href="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>参数的缓存与刷新机制 | 团队技术分享博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">团队技术分享博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">东区交付五部技术分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="team-manager">
      <meta itemprop="description" content="分享各小组的技术成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="团队技术分享博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          参数的缓存与刷新机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-28 20:13:14" itemprop="dateCreated datePublished" datetime="2023-02-28T20:13:14+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 08:55:36" itemprop="dateModified" datetime="2023-04-14T08:55:36+08:00">2023-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/" itemprop="url" rel="index"><span itemprop="name">缓存刷新</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/%E7%BC%93%E5%AD%98.JPG" class="">

<h2 id="参数简介"><a href="#参数简介" class="headerlink" title="参数简介"></a>参数简介</h2><p>众所周知，参数是我们在设计灵活可配置的应用程序时必不可少的一种手段。在不改变运行中的代码的前提下，通过修改参数的值来控制程序的执行结果。参数可以被持久化到数据库，可以被写入本地文件，也可以被缓存到JVM。</p>
<p>什么样的参数适合放入缓存？数据量可控，读多写少，允许集群内较小时间范围里不一致的参数可以放入缓存。</p>
<span id="more"></span>

<h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><p>在我们之前的开发过项目中，缓存的实现有以下几个方案，下面我们分析一下这几种方案的实现原理：</p>
<ul>
<li>本地缓存：把数据从数据库缓存到本地JVM中，应用程序在使用参数时直接从本地JVM中获取</li>
<li>配置中心：开源的配置中心，如携程开源的apollo，阿里开源的nacos</li>
<li>Redis缓存：使用Redis来缓存数据</li>
</ul>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>这种缓存的实现在我们不同项目中有三个不同的方案，但是原理基本一致。都是把持久化到数据的参数加载到JVM中，不同点是：前两种方案使用MQ广播参数变更的信息来使集群内所有应用实例进行本地缓存的刷新，从而达到缓存的一致性，而第三种方案则没有参数变更事件的广播。</p>
<blockquote>
<p>NOTE: 这三个方案并不是依次迭代的，它们之间没有关系。</p>
</blockquote>
<h4 id="本地缓存-方案一"><a href="#本地缓存-方案一" class="headerlink" title="本地缓存-方案一"></a>本地缓存-方案一</h4><p>通过Google的Guava类库提供的com.google.common.cache.LoadingCache作为缓存来存储从数据库加载的参数。该类可以通过expireAfterWrite方法设置缓存的过期时间，可以通过get或getIfPresent方法获取缓存中指定key的值。可以通过invalidate方法来手动把缓存置为失效。</p>
<p>整体的流程如下：</p>
<ol>
<li>在CacheLoader的load方法中定义参数查询方法，该方法就是通过参数key查询数据库中的参数表，把该key的参数信息按照key-value的形式存入缓存。</li>
<li>应用程序中使用参数时，通过LoadingCache的get方法直接从缓存中获取。</li>
<li>应用程序中更新参数时，先进行数据库的参数信息更新，然后用LoadingCache的invalidate方法把自己本地缓存中对应key删除，接着借助MQ进行参数变更的广播。</li>
<li>集群中其他的应用监听MQ的参数广播Topic。当应用程序在MQ队列中监听到参数变更消息后，同样把自己本地缓存中对应的key删除。</li>
<li>下次查询变更后的参数时，通过LoadingCache的get从缓存中获取，由于缓存中的参数已经删除，所以get方法会使用CacheLoader重新从数据库加载最新的参数。</li>
</ol>
<p>以下是代码样例，因为涉敏问题，以下代码全部都是简单的demo，只用来介绍思路,代码细节不太严谨。</p>
<figure class="highlight java"><figcaption><span>ParamServiceGuavaImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamServiceGuavaImpl</span> <span class="keyword">implements</span> <span class="title class_">ParamService</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LoadingCache&lt;String, Object&gt; cache;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getParam</span><span class="params">(Class&lt;T&gt; c, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里如果缓存中有，则返回，如果没有则用CacheLoader的方法去数据库查询</span></span><br><span class="line">      <span class="keyword">return</span> (T) <span class="built_in">this</span>.cache.get(key); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">updateParam</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    updateParamFromDataBase(key, t); <span class="comment">// 首先更新数据库中的参数信息</span></span><br><span class="line">    expireParamFromCache(key); <span class="comment">// 把缓存中的参数清除</span></span><br><span class="line">    broadcastParamChangeMsg(key, t); <span class="comment">// 用MQ广播参数变更消息</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 更新数据库中的参数信息</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">updateParamFromDataBase</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作省略</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 把缓存中的参数清除</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expireParamFromCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache.getIfPresent(key) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cache.invalidate(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用MQ广播参数变更消息</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">broadcastParamChangeMsg</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    <span class="comment">// MQ广播消息省略</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 从MQ消息队列中接受消息变更关播</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receivedParamChangeMsgFromMq</span><span class="params">(String key, Object sender)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sender != <span class="built_in">this</span>) &#123; <span class="comment">// 接受到其他应用发来的参数变更消息</span></span><br><span class="line">      expireParamFromCache(key); <span class="comment">// 清理本地缓存中对应的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache = CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterWrite(<span class="number">1</span>, TimeUnit.DAYS) <span class="comment">// 一天后自动过期</span></span><br><span class="line">        .ticker(Ticker.systemTicker())</span><br><span class="line">        .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> Object <span class="title function_">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 用参数key从数据库查询参数信息</span></span><br><span class="line">            <span class="keyword">return</span> queryParamFromDataBase(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用参数key从数据库查询参数信息</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">queryParamFromDataBase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地缓存-方案二"><a href="#本地缓存-方案二" class="headerlink" title="本地缓存-方案二"></a>本地缓存-方案二</h4><p>这种缓存实现方式与<code>本地缓存-方案一</code>原理基本一致，主要的区别有两点：</p>
<ol>
<li>用ConcurrentHashMap替换了Guava Cache。使用自定义的ConcurrentHashMap缓存参数就需要提供缓存的更新方法。</li>
<li>增加了定时轮询检查机制来解决参数更新广播信息的丢失问题。</li>
</ol>
<figure class="highlight java"><figcaption><span>ParamServiceConcurrentHashMapImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamServiceConcurrentHashMapImpl</span> <span class="keyword">implements</span> <span class="title class_">ParamService</span>, SmartLifecycle &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ParamWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String paramClass; <span class="comment">// 参数类</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, ParamModel&gt; paramModelMap; <span class="comment">// 同一参数类型不同的key</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ParamModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Object paramObject;</span><br><span class="line">    <span class="keyword">private</span> String lastUpdateTime;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 参数缓存，key是参数类型，value是该类型下所有的参数</span></span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, ParamWrapper&gt; cache </span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ParamWrapper&gt;();</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getParam</span><span class="params">(Class&lt;T&gt; c, String key)</span> &#123;</span><br><span class="line">    <span class="type">ParamWrapper</span> <span class="variable">paramWrapper</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(c.getCanonicalName());</span><br><span class="line">    <span class="keyword">if</span> (paramWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      paramWrapper = <span class="keyword">new</span> <span class="title class_">ParamWrapper</span>();</span><br><span class="line">      paramWrapper.setParamClass(c.getCanonicalName());</span><br><span class="line">      paramWrapper.setParamModelMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ParamModel&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    ConcurrentHashMap&lt;String,ParamModel&gt; paramModelMap = paramWrapper.getParamModelMap();</span><br><span class="line">    <span class="keyword">if</span> (!paramModelMap.contains(key)) &#123;</span><br><span class="line">      <span class="type">ParamModel</span> <span class="variable">t</span> <span class="operator">=</span> (ParamModel) queryParamFromDataBase(key);</span><br><span class="line">      paramModelMap.put(key, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) paramModelMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用参数key从数据库查询参数信息</span></span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">queryParamFromDataBase</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">updateParam</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    updateParamFromDataBase(key, t); <span class="comment">// 首先更新数据库中的参数信息</span></span><br><span class="line">    expireParamFromCache(key, t); <span class="comment">// 把缓存中的参数清除</span></span><br><span class="line">    broadcastParamChangeMsg(key, t); <span class="comment">// 用MQ广播参数变更消息</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 更新数据库中的参数信息</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">updateParamFromDataBase</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作省略</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 把缓存中的参数清除</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">expireParamFromCache</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    <span class="type">ParamWrapper</span> <span class="variable">paramWrapper</span> <span class="operator">=</span> <span class="built_in">this</span>.cache.get(t.getClass().getCanonicalName());</span><br><span class="line">    <span class="keyword">if</span> (paramWrapper != <span class="literal">null</span>) &#123;</span><br><span class="line">      paramWrapper.getParamModelMap().remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用MQ广播参数变更消息</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">broadcastParamChangeMsg</span><span class="params">(String key, T t)</span> &#123;</span><br><span class="line">    <span class="comment">// MQ广播消息省略</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 从MQ消息队列中接受消息变更关播</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">receivedParamChangeMsgFromMq</span><span class="params">(String key, T t, Object sender)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sender != <span class="built_in">this</span>) &#123; <span class="comment">// 接受到其他应用发来的参数变更消息</span></span><br><span class="line">      expireParamFromCache(key, t); <span class="comment">// 清理本地缓存中对应的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> ThreadPoolTaskScheduler paramCacheCheckTaskScheduler;</span><br><span class="line">  <span class="keyword">private</span> ScheduledFuture&lt;?&gt; watchFuture;   </span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paramCacheCheckTaskScheduler = <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">    <span class="built_in">this</span>.paramCacheCheckTaskScheduler.setBeanName(<span class="string">&quot;paramCacheCheckTaskScheduler&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.paramCacheCheckTaskScheduler.setThreadNamePrefix(<span class="string">&quot;param-cache-check-&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.paramCacheCheckTaskScheduler.initialize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.running.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.watchFuture = <span class="built_in">this</span>.paramCacheCheckTaskScheduler.scheduleWithFixedDelay(</span><br><span class="line">          <span class="built_in">this</span>::checkParamCache, <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 每个1分钟进行一次参数检查</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 缓存参数检查</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkParamCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, ParamWrapper&gt; entry : <span class="built_in">this</span>.cache.entrySet()) &#123;</span><br><span class="line">      <span class="comment">// 检查参数数量是否一致</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">dbSize</span> <span class="operator">=</span> countParamFromDatabase(entry.getKey());</span><br><span class="line">      <span class="keyword">if</span> (dbSize != entry.getValue().getParamModelMap().size()) &#123;</span><br><span class="line">        <span class="comment">// 参数数量不一致则清理缓存</span></span><br><span class="line">        entry.getValue().getParamModelMap().clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 检查参数最后更新日期是否一致</span></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;String, ParamModel&gt; cacheEntry : entry.getValue().getParamModelMap().entrySet()) &#123;</span><br><span class="line">        <span class="type">ParamModel</span> <span class="variable">dbParamModel</span> <span class="operator">=</span> (ParamModel) queryParamFromDataBase(cacheEntry.getKey());</span><br><span class="line">        <span class="comment">// 数据库与缓存中的最后更新日期不一致则清理缓存</span></span><br><span class="line">        <span class="keyword">if</span> (cacheEntry.getValue().getLastUpdateTime().compareTo(dbParamModel.getLastUpdateTime()) != <span class="number">0</span>) &#123;</span><br><span class="line">          entry.getValue().getParamModelMap().remove(cacheEntry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">countParamFromDatabase</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 从数据库计算参数的总个数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.running.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>) &amp;&amp; <span class="built_in">this</span>.watchFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.watchFuture.cancel(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.running.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地缓存-方案三"><a href="#本地缓存-方案三" class="headerlink" title="本地缓存-方案三"></a>本地缓存-方案三</h4><p>方案三也是把参数缓存到ConcurrentHashMap中，通过自定缓存实现类来把数据库中不同表中的数据加载到本地缓存，与方案二的主要区别有几点：</p>
<ol>
<li>方案三支持把数据库中不同表中的数据放入缓存，而方案二则只允许把特定的一张参数表的参数放入缓存。</li>
<li>方案三没有参数变更的关播机制，无法及时通使用到该参数的其他实例进行本地缓存的刷新，只能依赖每台应用实例各自的轮询任务去检测本地缓存是否需要更新。</li>
<li>方案三有缓存自动过期机制。</li>
<li>方案三提供了抽象的缓存管理，开发人员可以通过自定义的缓存实现类把任何想要放入缓存的数据加入缓存。</li>
</ol>
<figure class="highlight java"><figcaption><span>AbstractLocalCache.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLocalCache</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">protected</span> ConcurrentHashMap&lt;String, T&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, T&gt;();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 用内存与数据库缓存刷新标识信息进行对比，若不一致则说明本地缓存需要刷新</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lastRefreshStr</span> <span class="operator">=</span> <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 默认缓存过期时间是1小时</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">  <span class="comment">// 默认缓存生效开始时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">effectStartTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 判断缓存是否过期</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() - effectStartTime &gt;= expireTime) &#123;</span><br><span class="line">      <span class="comment">// 用当前时间减去缓存生效开始时间，如果超过了过期时间，则该缓存过期</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 设置缓存过期</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExpire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.effectStartTime = <span class="number">0L</span>; <span class="comment">// 通过把缓存生效日期重置为0，来达到缓存过期的目的</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    loadCache(); <span class="comment">// 加载缓存</span></span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isExpire()) &#123; <span class="comment">// 如果缓存过期则重新加载</span></span><br><span class="line">      <span class="comment">// 从数据库加载信息到缓存</span></span><br><span class="line">      loadCacheFromDatabase();</span><br><span class="line">      <span class="comment">// 设置缓存生效的开始时间</span></span><br><span class="line">      <span class="built_in">this</span>.effectStartTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 从数据库中加载信息到缓存中</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">loadCacheFromDatabase</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">// 获取缓存刷新标识</span></span><br><span class="line">  <span class="keyword">abstract</span> String <span class="title function_">getCacheRefreshFlag</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getLastRefreshStr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastRefreshStr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastRefreshStr</span><span class="params">(String lastRefreshStr)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastRefreshStr = lastRefreshStr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>ParamServiceImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractLocalCache</span>&lt;Param&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String refreshFlag;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">loadCacheFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">    cache = loadParaMap();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Param&gt; <span class="title function_">loadParaMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  String <span class="title function_">getCacheRefreshFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> refreshFlag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Param</span> &#123;</span><br><span class="line">  <span class="comment">// 自定义的参数结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>CacheRefreshService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheRefreshService</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> ApplicationContext ctx;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Scheduled(cron = &quot;自定义缓存刷新间隔时间&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; cacheServiceImplNames = getCacheServiceImplNames();</span><br><span class="line">    <span class="keyword">for</span> (String serviceName : cacheServiceImplNames) &#123;</span><br><span class="line">      AbstractLocalCache&lt;?&gt; bean = ctx.getBean(serviceName, AbstractLocalCache.class);</span><br><span class="line">      <span class="type">RefreshFlag</span> <span class="variable">refreshFlagData</span> <span class="operator">=</span> loadRefreshFlagFromDatabase(bean.getCacheRefreshFlag());</span><br><span class="line">      <span class="keyword">if</span> (!refreshFlagData.getRefreshFlagData().equals(bean.getLastRefreshStr())) &#123;</span><br><span class="line">        <span class="comment">// 数据库中的缓存标识信息与内存中的不一样，则说明需要刷新缓存</span></span><br><span class="line">        bean.setExpire();</span><br><span class="line">        bean.setLastRefreshStr(refreshFlagData.getRefreshFlagData());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 获取所有缓存实现类的名称</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getCacheServiceImplNames</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 实现内容省略</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> RefreshFlag <span class="title function_">loadRefreshFlagFromDatabase</span><span class="params">(String refreshFlag)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 用缓存刷新标识到数据库查询出缓存刷新标识的信息</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">RefreshFlag</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String refreshFlagData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>前面介绍了我们项目中使用过的三种本地缓存的实现方案，接下来我们分析一下目前比较流行的开源的配置中心。来看看它们是如何进行配置的读取和配置变更的实时生效。</p>
<h4 id="apollo配置中心"><a href="#apollo配置中心" class="headerlink" title="apollo配置中心"></a>apollo配置中心</h4><p>apollo配置中心是携程开源的项目。它主要分为<code>apollo-portal</code>、<code>apollo-adminservice</code>、<code>apollo-configservice</code>、<code>apollo-client</code>四部分组成。portal、adminservice、configservice可分别单独部署，更加详细的部署方案可以阅读这篇文章<a target="_blank" rel="noopener" href="https://www.apolloconfig.com/#/zh/deployment/deployment-architecture">https://www.apolloconfig.com/#/zh/deployment/deployment-architecture</a>。</p>
<p>apollo-client以jar包的方式集成到应用程序中，应用程序通过apollo-client来获取配置参数。关于客户端的设计原理可以阅读这篇文章：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/open-source-configuration-center-apollo">https://www.infoq.cn/article/open-source-configuration-center-apollo</a>。</p>
<p><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/apollo.jpg" alt="apollo.jpg"></p>
<p>apollo客户端通过短轮询+长轮询的方式，从apollo-configservice中读取配置信息。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/pollandquery.jpg" alt="pollandquery.jpg"></p>
<p>短轮询就是通过ScheduledExecutorService线程池，按照一定的间隔时间，用http的方式从apollo-configservice拉取最新的配置信息。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/s-s-p.jpg" alt="s-s-p.jpg"><br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/queryConfig.jpg" alt="queryConfig.jpg"></p>
<p>长轮询就是通过apollo-client发起http请求到apollo-configservice的<code>/notifications/v2</code>接口，该接口不会马上返回，而是用Spring的<code>DeferredResult</code>把请求挂起。如果在60秒内没有该客户端关心的配置发布，那么会返回Http状态码304给客户端。如果有该客户端关心的配置发布，则会调用DeferredResult的setResult方法，传入有配置变化的namespace信息，同时该请求会立即返回。客户端从返回的结果中获取到配置变化的namespace后，会立即请求Config Service获取该namespace的最新配置。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/poll.jpg" alt="poll.jpg"></p>
<p>源码的分析可以阅读这篇文章<a target="_blank" rel="noopener" href="https://www.iocoder.cn/Apollo/client-polling-config/">https://www.iocoder.cn/Apollo/client-polling-config/</a>, 这位博主写的apollo的源码分析非常的深入，这里我大致介绍一下流程：</p>
<ol>
<li>客户端在启动后，通过DefaultConfigFactory来创建一个Config类，该类就是用来获取配置的入口。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/configfactory.jpg" alt="configfactory.jpg"></li>
<li>在创建Config的过程中，创建了RemoteConfigRepository类，在该类的构造方法中创建了一个重要的用来长轮询的类RemoteConfigLongPollService。然后通过http请求的方式从远程<code>apollo-configservice</code>中读取到了配置信息。接着启动了短轮询任务，最后启动了长轮询类RemoteConfigLongPollService的长轮询任务。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/RemoteConfigRepository.jpg" alt="RemoteConfigRepository.jpg"></li>
<li>RemoteConfigRepository的短轮询任务会每隔5分钟发送http请求到apollo-configservice获取一次配置信息。apollo-configservice的ConfigService实现类会到数据库中的Release表中查询出配置信息。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/configservice.jpg" alt="configservice.jpg"><br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/release.jpg" alt="release.jpg"></li>
<li>RemoteConfigLongPollService的长轮询任务会发送http请求到apollo-configservice的<code>/notifications/v2</code>接口，并被挂起。当有配置发生变化时，apollo-configservice会返回请求，并携带配置变更发布信息(不是配置变更后的结果)，RemoteConfigLongPollService收到后会通知RemoteConfigRepository马上进行一次http请求，获取最新的配置。同时RemoteConfigLongPollService会马上发起长轮询请求，继续被挂起。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/notify.jpg" alt="notify.jpg"></li>
<li>apollo-client从apollo-configservice获取到配置信息后，会缓存到本地JVM，同时也会在写入本地文件中，文件的写入是用LocalFileConfigRepository类的setUpstreamRepository方法实现的。当apollo-configservice宕机后，客户端可以从本地文件中读取配置信息。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/file.jpg" alt="file.jpg"></li>
<li>apollo-client启动时会创建DefaultConfig类，该类中的m_configProperties属性中缓存了RemoteConfigRepository从远程查回来的的配置。通过Config获取参数的顺序如下图：<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/step.jpg" alt="step.jpg"></li>
</ol>
<h4 id="nacos配置中心"><a href="#nacos配置中心" class="headerlink" title="nacos配置中心"></a>nacos配置中心</h4><p>nacos是阿里开源的项目，支持几乎所有主流类型的“服务”的发现、配置和管理。我们也有项目在使用。nacos详细介绍可以阅读这篇文章：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a> 。关于<code>动态配置服务</code>中配置一致性模型的介绍如下:<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/nacos1.jpg" alt="nacos1.jpg"></p>
<p>nacos配置中心作为服务端单独部署，应用程序通过jar的方式集成nacos客户端，客户端从服务端获取配置信息并在本地已文件方式缓存一份。应用程序通过客户端获取配置信息时，先从本地文件中获取，如果存在则返回配置信息，如果不存在则访问服务端获取配置信息。<br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/nacos2.jpg" alt="nacos2.jpg"></p>
<blockquote>
<p>NOTE: nacos的源码分析还在继续。。。。。。</p>
</blockquote>
<h3 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h3><p>众说周知，Redis 是一个内存数据库，数据保存在内存中，所以查询是速度比查询普通关系型数据库要快的多。Redis也支持把数据持久化到磁盘，方式有AOF、RDB和两种混合方式。Redis和应用程序是分开部署的，所以要访问Redis内存中的数据，是有一个网络开销的，所以速度比访问本地JVM内存要慢。</p>
<p>我们把Redis作为缓存来使用时，除了要考虑集群间消息同步延迟产生的缓存不一致外，在应用开发层面特别需要重点考虑的是缓存数据的刷新时机。当数据产生变化时，更新数据和缓存的顺序不同，有可能产生的影响也不同。通过调整更新顺序可以降低这种<code>双写一致性</code>的问题，但是不能彻底避免。</p>
<p>Redis 6.0版本新增了客户端缓存功能《Client-side caching in Redis》，称之为<code>Tracking</code>，通过在客户端缓存数据来减轻Redis服务端的压力。文档连接为:<a target="_blank" rel="noopener" href="https://redis.io/docs/manual/client-side-caching/">https://redis.io/docs/manual/client-side-caching/</a><br><img src="/2023/02/28/%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/redis.jpg" alt="redis.jpg"><br>Redis客户端缓存也同样要解决缓存数据一致性问题。Redis提供了两种方式来提醒客户的端缓存过期：默认模式、广播模式。</p>
<blockquote>
<p>The Redis implementation of client-side caching<br>The Redis client-side caching support is called Tracking, and has two modes:</p>
<ul>
<li>In the default mode, the server remembers what keys a given client accessed, and sends invalidation messages when the same keys are modified. This costs memory in the server side, but sends invalidation messages only for the set of keys that the client might have in memory.</li>
<li>In the broadcasting mode, the server does not attempt to remember what keys a given client accessed, so this mode costs no memory at all in the server side. &gt;Instead clients subscribe to key prefixes such as object: or user:, and receive a notification message every time a key matching a subscribed prefix is touched.</li>
</ul>
</blockquote>
<p>开源组件中Redis客户端缓存支持情况</p>
<table>
<thead>
<tr>
<th>开源组件</th>
<th>是否支持</th>
<th>进展</th>
</tr>
</thead>
<tbody><tr>
<td>jedis</td>
<td>不支持</td>
<td>开发中，issue:<a target="_blank" rel="noopener" href="https://github.com/redis/jedis/issues/2220">https://github.com/redis/jedis/issues/2220</a></td>
</tr>
<tr>
<td>lettuce</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>redisson</td>
<td>支持</td>
<td>改进中，issue:<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/issues/2936">https://github.com/redisson/redisson/issues/2936</a></td>
</tr>
</tbody></table>
<h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><p>本篇我们详细介绍了本地缓存的三种实现方案，简单介绍了开源的配置中心原理，指出了在使用Redis做缓存时需要考虑的问题。我们可以得出几点经验：</p>
<ul>
<li>从访问速度上 本地内存 &gt; 旁路缓存 &gt; 数据库</li>
<li>可以通过 <code>推送</code> + <code>拉取</code> 两种方式来保证集群内本地缓存的一致性</li>
<li><code>推送</code> 的是缓存变更的事件，推送的目的时提醒客户端马上进行一次缓存的<code>拉取</code></li>
<li>Redis缓存在高并发场景下，有<code>双写一致性</code>问题，解决方案有要按照实际业务场景来选择</li>
</ul>
<table>
<thead>
<tr>
<th>比较</th>
<th>本地缓存一</th>
<th>本地缓存二</th>
<th>缓存缓存三</th>
<th>apollo</th>
<th>nacos</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>缓存方式</td>
<td>JVM</td>
<td>JVM</td>
<td>JVM</td>
<td>JVM + 本地文件</td>
<td>本地文件</td>
<td>客户端缓存</td>
</tr>
<tr>
<td>刷新方式</td>
<td>MQ广播通知</td>
<td>MQ广播通知 + 定时拉取</td>
<td>定时拉取</td>
<td>短轮询拉取 + 长轮询通知</td>
<td>广播通知 + ？</td>
<td>默认模式 or 广播模式</td>
</tr>
<tr>
<td>是否支持主动过期</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>改进方案</td>
<td>增加主动检查来避免缓存广播信息丢失产生的参数不一致</td>
<td>无</td>
<td>增加缓存变更广播功能，缩短缓存不一致的时间</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8F%82%E6%95%B0/" rel="tag"># 参数</a>
              <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/22/MVCC/" rel="prev" title="MVCC">
      <i class="fa fa-chevron-left"></i> MVCC
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/01/elastic-search-%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/" rel="next" title="elastic search 基础实践">
      elastic search 基础实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">参数简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">缓存方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-number">2.1.</span> <span class="nav-text">本地缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-%E6%96%B9%E6%A1%88%E4%B8%80"><span class="nav-number">2.1.1.</span> <span class="nav-text">本地缓存-方案一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">本地缓存-方案二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98-%E6%96%B9%E6%A1%88%E4%B8%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">本地缓存-方案三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">2.2.</span> <span class="nav-text">配置中心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">2.2.1.</span> <span class="nav-text">apollo配置中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">2.2.2.</span> <span class="nav-text">nacos配置中心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98"><span class="nav-number">2.3.</span> <span class="nav-text">Redis缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">内容总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">team-manager</p>
  <div class="site-description" itemprop="description">分享各小组的技术成果</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">team-manager</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
